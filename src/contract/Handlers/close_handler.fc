int isPayoutImpossible(int reqShare, int reqPayout, int otherShare) {
  return (otherShare < reqPayout) | (reqShare < - reqPayout);
}

() throw_if_payoutImpossible(int reqShare, int reqPayout, int otherShare) impure {
  throw_when(
    Close::PayoutImpossible(),
    isPayoutImpossible(reqShare, reqPayout, otherShare)
    );
}

cell createStateClosing(int reqPkn, cell localState, cell closeReq) impure {
   return mkStateClosing(
     reqPkn,
     getOpenState(localState),
     closeReq,
     now()
     );
}

cell payoutMatches(
  slice addr1, slice addr2,
  int payout1, int payout2,
  int share1, int share2) impure {

  if (- payout1 > share2) {
    payout1 = - share2;
  }

  if (- payout2 > share1) {
    payout2 = - share1;
  }

  proceedPayout2(addr1, share1 + payout1, addr2, share2 + payout2);
  return terminateContract();
}
;; iou, uome, iou_ok
(int, int, int) parseMIou(cell miou, int pk) impure {
  var s = miou.begin_parse();
  var maybeTag = s~load_uint(1);
  if (maybeTag == 0) {
    return (0, 0, true);
  } else {
    var iouS = s~load_bits(slice_bits(s));
    var iouC = begin_cell().store_slice(iouS).end_cell();
    var (_, iou, uome, sign_ok, addr_ok) = parseIouQ(iouC, pk);
    return (iou, uome, sign_ok & addr_ok);
  }
}

cell disputeOccured(
  cell closeReq1,
  cell closeReq2,
  cell globalState,
  cell openState) {

  var (pk1, pk2, share1, share2, _, fine, _)
    = parseGlobalState(globalState);

  var (addr1, addr2) = parseOpenState(openState.begin_parse());

  var (payout1, miou1) = parseCloseReq(closeReq1);
  var (payout2, miou2) = parseCloseReq(closeReq2);

  var (iou1, uome1, iou_ok1) = parseMIou(miou1, pk2);
  var (iou2, uome2, iou_ok2) = parseMIou(miou2, pk1);

  var owes1 = max(iou1 - payout1, iou2);
  var owes2 = max(iou2 - payout2, iou1);

  if (iou_ok1 & iou_ok2) {
    var finalPayout = owes2 - owes1;

    proceedPayout2(
      addr1, share1 + finalPayout + fine,
      addr2, share2 - finalPayout + fine
      );

    return terminateContract();
  } elseif ((~ iou_ok1) & iou_ok2) {
    var finalPayout = owes2 - owes1;

    proceedPayout2(
      addr1, share1 + finalPayout,
      addr2, share2 - finalPayout + (2 * fine)
      );

    return terminateContract();
  } elseif (iou_ok1 & (~ iou_ok2)) {
    var finalPayout = owes2 - owes1;

    proceedPayout2(
      addr1, share1 + finalPayout + (2 * fine),
      addr2, share2 - finalPayout
      );

    return terminateContract();
  } else {
    return mkStateOpen(addr1, addr2);
  }

}

cell handle_close(
  int msg_pkn,
  cell closeReq,
  cell globalState,
  cell localState) impure {

  var ls = localState.begin_parse();
  var stateTag = ls.preload_StateTag();

  var (pk1, pk2, share1, share2, _, fine, _)
    = parseGlobalState(globalState);

  var (payout, mIou) = parseCloseReq(closeReq);

  if (stateTag == StateTags::Open()) {
    ;; Open -> Closing
    if (msg_pkn == 1) {
      ;; current msg from party1
      ;; reqShare = share1;
      ;; reqPk = pk1;
      ;; otherShare = share2;
      throw_if_payoutImpossible(share1, payout, share2);
      return createStateClosing(1, localState, closeReq);
    } else {
      ;; current msg from party2
      ;; reqShare = share2;
      ;; reqPk = pk2;
      ;; otherShare = share1;
      throw_if_payoutImpossible(share2, payout, share1);
      return createStateClosing(2, localState, closeReq);
    }
  } elseif(stateTag == StateTags::Closing()) {
    ;; Closing -> ???
    var (prevReqPkn, openState, prevCloseReq, prevTimestamp) =
      parseStateClosing(ls);

    var (prevPayout, prevMIou) = parseCloseReq(prevCloseReq);
    var (addr1, addr2) = parseOpenState(openState.begin_parse());

    if (payout + prevPayout == 0) {

      if (msg_pkn == 1) {
        ;; current msg from party1
        ;; payout1 = payout;
        ;; payout2 = prevPayout;
        return payoutMatches(
          addr1, addr2,
          payout, prevPayout,
          share1, share2
          );
      } else {
        ;; current msg from party2
        ;; payout1 = prevPayout;
        ;; payout2 = payout;
        return payoutMatches(
          addr1, addr2,
          prevPayout, payout,
          share1, share2
        );
      }
    } else {
      if (msg_pkn == 1) {
        return disputeOccured(
          closeReq,
          prevCloseReq,
          globalState,
          openState
          );
      } else {
        return disputeOccured(
          prevCloseReq,
          closeReq,
          globalState,
          openState
          );
      }
    }
  } else {
    ;; Unknown state transition
    throw(Close::InvalidState());
    return unreachableReturn();
  }
}
