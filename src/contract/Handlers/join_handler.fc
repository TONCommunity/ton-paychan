;; all handlers produce new LocalState as cell
cell handle_join(
   slice msg_src_addr,
   int msg_value,
   int msg_pk,
   cell globalState,
   cell localState) {

   var (pk1, pk2, share1, share2, _, _, _)
     = parseGlobalState(globalState);

   var ls = localState.begin_parse();
   var (_, stateTag) = ls.load_StateTag();

   if (stateTag == StateTags::WaitingBoth()) {
     ;; WaitingBoth -> WaitingOne s_addr pk
     var requesterShare = msg_pk.pk2Share(globalState);

     ;; supplied not enough
     throw_when(Join::SuppliedNotEnough1(), requesterShare > msg_value);

     return mkStateWaitingOne(msg_src_addr, msg_pk);
   } elseif (stateTag == StateTags::WaitingOne()) {
     ;; WaitingOne addr1 pk1 -> Open (OpenState addr1 addr2)
     var (stateAddr, statePk) = parseStateWaitingOne(ls);

     if ((statePk == pk1) & (pk2 == msg_pk)) {
       throw_when(Join::SuppliedNotEnough2(), share2 > msg_value);
       return mkStateOpen(stateAddr, msg_src_addr);
     } elseif ((statePk == pk2) & (pk1 == msg_pk)) {
       throw_when(Join::SuppliedNotEnough2(), share1 > msg_value);
       return mkStateOpen(msg_src_addr, stateAddr);
     } else {
       throw(Join::UnknownParty());
       return localState;
     }
   } else {
     ;; none of appropriate states for this message matches
     throw(Join::InvalidState());
     return unreachableReturn();
   }
 }
