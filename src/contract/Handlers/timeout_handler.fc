cell handle_timeout(
  int msg_pk,
  cell globalState,
  cell localState) impure {

  var ls = localState.begin_parse();
  var (_, stateTag) = ls.load_StateTag();

  var (pk1, pk2, share1, share2, timeout, fine, _)
    = parseGlobalState(globalState);

  if (stateTag == StateTags::WaitingBoth()) {
    ;; TODO: send all funds to contract with addr 0?
    return terminateContract();
  } elseif (stateTag == StateTags::WaitingOne()) {
    var (addr, pk) = parseStateWaitingOne(ls);
    var share = pk.pk2Share(globalState);
    proceedPayout(addr, share + fine);
    return terminateContract();
  } elseif (stateTag == StateTags::Closing()) {
    var (prevReqPk, openState, closeReq, prevTimestamp) =
      parseStateClosing(ls);

    ;; timeout from other party
    throw_unless_(Timeout::WrongParty(), msg_pk == prevReqPk);

    var (addr1, addr2) = parseOpenState(openState.begin_parse());

    var (reqPayout, _) = parseCloseReq(closeReq);
    if ((now() - prevTimestamp) > timeout) {
      if (msg_pk == pk1) {
        proceedPayout2(
          addr1, share1 + reqPayout + (2 * fine),
          addr2,  share2 - reqPayout
          );
        return terminateContract();
      } elseif (msg_pk = pk2) {
        proceedPayout2(
          addr1, share1 - reqPayout,
          addr2, share2 + reqPayout + (2 * fine)
          );
        return terminateContract();
      } else {
        throw(Timeout::UnknownAddress());
        return unreachableReturn();
      }
    } else {
      ;; timeout initiated too early
      throw(Timeout::TooEarly());
      return unreachableReturn();
    }
  } else {
    ;; transition not possible
    throw(Timeout::InvalidState());
    return unreachableReturn();
  }
}
