cell handle_timeout(
  int msg_pk,
  cell globalState,
  cell localState) impure {

  var ls = localState.begin_parse();
  var stateTag = ls.preload_StateTag();

  var (pk1, pk2, share1, share2, timeout, fine, _)
    = parseGlobalState(globalState);

  if (stateTag == StateTags::WaitingBoth()) {
    ;; TODO: send all funds to contract with addr 0?
    return terminateContract();
  } elseif (stateTag == StateTags::WaitingOne()) {
    var (addr, pkn) = parseStateWaitingOne(ls);
    var share = globalState.pkn2share(pkn);
    proceedPayout(addr, share + fine);
    return terminateContract();
  } elseif (stateTag == StateTags::Closing()) {
    var (prevReqPk, openState, closeReq, prevTimestamp) =
      parseStateClosing(ls);

    ;; timeout from other party
    throw_unless_(Timeout::WrongParty(), msg_pk == prevReqPk);

    var (addr1, addr2) = parseOpenState(openState.begin_parse());

    var (reqPayout, _) = parseCloseReq(closeReq);
    if ((now() - prevTimestamp) > timeout) {
      if (prevReqPk == pk1) {
        return disputeOccured(
          closeReq,
          emptyCloseReq(),
          globalState,
          openState
          );
      } elseif (prevReqPk = pk2) {
        return disputeOccured(
          emptyCloseReq(),
          closeReq,
          globalState,
          openState
          );
      } else {
        throw(Timeout::UnknownAddress());
        return unreachableReturn();
      }
    } else {
      ;; timeout initiated too early
      throw(Timeout::TooEarly());
      return unreachableReturn();
    }
  } else {
    ;; transition not possible
    throw(Timeout::InvalidState());
    return unreachableReturn();
  }
}
